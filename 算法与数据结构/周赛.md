#### 157场双周赛
[3558.给边权赋值的方案数Ⅰ](https://leetcode.cn/problems/number-of-ways-to-assign-edge-weights-i/)  
考察：基础邻接表（无向图），树的最大深度，组合数学  
1. 结合图里的知识，对于**无向图**（注意无向图两边都需要添加节点），先构造邻接表：
```python
edges = [[1, 2], [2, 3] ...]
n = len(edges) + 1 # 有n条边，所以有n+1个节点
g = [[] for _ in range(n + 1)] # 又因为本题节点是1到n，所以其实用的是1到n的邻接表，0表示开始无节点
for u, v in edges:
    g[u].append(v)
    g[v].append(u)
```
2. 树的最大深度？二叉树有学过: [104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)  
   - 其实这个无向树跟二叉树一样的，只是孩子变多了，表达方式变成邻接表了罢了
```python
def dfs(x: int, fa: int) -> int:
    d = 0 # 节点x的深度 这里不包括源节点
    for y in g[x]:
        if y != fa: # 递归不会去父节点
            d = max(d, dfs(y, x) + 1)
    return d
```
3. 最后组合数学，二项式定理推来的
$$
C_n^1 + C_n^3 + C_n^5 + \cdots = 2^{n-1}
$$

最终代码:
```python
class Solution:
    def assignEdgeWeights(self, edges: List[List[int]]) -> int:
        MOD = 1_000_000_007
        n = len(edges) + 1
        g = [[] for _ in range(n + 1)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)

        def dfs(x: int, fa: int) -> int:
            d = 0
            for y in g[x]:
                if y != fa:  # 不递归到父节点
                    d = max(d, dfs(y, x) + 1)
            return d

        k = dfs(1, 0)
        return pow(2, k - 1, MOD)
```


