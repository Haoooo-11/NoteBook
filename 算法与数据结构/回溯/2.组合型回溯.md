## 组合型回溯
[【回溯算法套路②组合型回溯+剪枝【基础算法精讲 15】】](https://www.bilibili.com/video/BV1xG4y1F7nC?vd_source=1e683c3cb93400956a910790b98ffccb)  

题目：[77.组合](https://leetcode.cn/problems/combinations/)
![](回溯-Pictures\2-1.png)
可以发现是倒序枚举的，一会会讲为什么
![](回溯-Pictures\2-2.png)
解释如图：
![](回溯-Pictures\2-5.png)
```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        # 选/不选
        # ans = []
        # path = []

        # def dfs(i: int) -> None:
        #     d = k - len(path)  # 还要选 d 个数
        #     if d == 0:  # 选好了
        #         ans.append(path.copy())
        #         return

        #     # 如果 i > d，可以不选 i
        #     if i > d:
        #         dfs(i - 1)

        #     # 选 i
        #     path.append(i)
        #     dfs(i - 1)
        #     path.pop()  # 恢复现场

        # dfs(n)
        # return ans

        # 枚举选哪个
        ans = []
        path = []

        def dfs(i):
            d = k - len(path)
            if d == 0:
                ans.append(path.copy())
                return
            
            if i < d:
                return
            
            for j in range(i, 0, -1):
                path.append(j)
                dfs(j-1)
                path.pop()
            
        dfs(n)
        return ans
```
---
那么如何分析回溯的时间复杂度呢？  
叶子节点个数 ✖ 根到叶的深度

![](回溯-Pictures\2-3.png)


[216.组合总数III](https://leetcode.cn/problems/combination-sum-iii/)  
剪枝更多了
![](回溯-Pictures\2-4.png)
```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        # ans = []
        # path = []
        # def dfs(i, t): # t表示还要找和为t的和 i表示在[1,i]选数字（一共有i个给你选）
        #     d = k - len(path) # 还要选d个数
        #     if t < 0 or t > (i * 2 - d + 1) * d // 2: # 剪枝：t<0表示此时选的数的和已经大于n，不必要继续了
        #         return
        #     if d == 0:                                # t>这一坨：是表示还要选d个数字时把最大的d个选了还达不到n
        #         ans.append(path.copy())
        #         return
        #     # 不选i
        #     if d < i:
        #         dfs(i-1, t)
        #     # 选i
        #     path.append(i)
        #     dfs(i-1, t-i)
        #     path.pop()
        
        # dfs(9, n)
        # return ans

        ans = []
        path = []

        def dfs(i, t):
            d = k - len(path)
            if i < d:
                return
            
            if t < 0 or t > (i + i - d + 1) * d // 2:
                return
            
            if d == 0: # why不判断t==0？因为上面已经判断t<0 / t>0了，能下来的话t肯定==0
                ans.append(path.copy())
                return
            
            for j in range(i, 0, -1):
                path.append(j)
                dfs(j-1, t-j)
                path.pop()
            
        dfs(9, n)
        return ans
```

[22.括号生成](https://leetcode.cn/problems/generate-parentheses/description/)  
为什么放在组合型回溯呢？ 括号生成和组合型回溯的思路很像：
- 重复构造增量，且有相似子问题
- 选'('，相当于选;      
- 选')'，相当于不选
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        m = n * 2
        ans = []
        path = []
        def dfs(i, open): # open是记录了左括号的个数
            if i == m:
                ans.append(''.join(path.copy()))
                return
            if i - open < open: # 不选（相当于选")"）
                path.append(')')
                dfs(i+1, open)
                path.pop()
            if open < n: # 选 选了(
                path.append('(')
                dfs(i+1, open+1)
                path.pop()
        dfs(0, 0)
        return ans
```
