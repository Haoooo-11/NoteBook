## 子集型回溯
[【回溯算法套路①子集型回溯【基础算法精讲 14】】](https://www.bilibili.com/video/BV1mG4y1A7Gu?vd_source=1e683c3cb93400956a910790b98ffccb)

![](回溯-Pictures\1-1.png)
![](回溯-Pictures\1-2.png)
**增量构造答案**的过程，就是**回溯**的特点，适合用递归解决！！

回溯思考和动态规划问题的思考过程：
![](回溯-Pictures\1-3.png)
- 这里的递归参数i表示很重要：不是表示第i个，而是表示**下标≥i**这一部分我们还需要枚举
- 也可以理解为层：第i层  

[17.电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)
```python
MAPPING = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        # 这是先构造一个长为n的数组，直接替换填入 -> 不用恢复现场
        # n = len(digits)
        # if n == 0:
        #     return []
        # ans = []
        # path = [''] * n
        # def dfs(i):
        #     if i == n:
        #         ans.append(''.join(path))
        #         return
        #     for c in MAPPING[int(digits[i])]:
        #         path[i] = c
        #         dfs(i+1)
        # dfs(0)
        # return ans        
        n = len(digits)
        if n == 0:
            return []
        ans = []
        path = [] # 空path记得要恢复现场
        def dfs(i):
            if i == n:
                ans.append(''.join(path.copy()))
                return
            # 不用copy的话 你path是全局的，这里即便放进去也是引用，后面已修改path 这边ans的结果也会变
            for c in MAPPING[int(digits[i])]: # 枚举各个字符，每个都可以回溯
                path.append(c)
                dfs(i+1)
                path.pop() # 恢复现场
        
        dfs(0)
        return ans
```
### 两种思考模式
区别在于当前操作是什么，分为站在**输入**和**输出**的角度来思考，就会出现两种思考模式：  

用同一个例题：[78.子集](https://leetcode.cn/problems/subsets/)
#### ① 输入角度 选/不选
![](回溯-Pictures\1-4.png)
和前面的层来理解就很容易了
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        ans = []
        path = []
        n = len(nums)

        def dfs(i):
            if i == n:
                ans.append(path.copy())
                return

            # 不选
            dfs(i+1) 

            # 选
            path.append(nums[i])
            dfs(i+1)
            path.pop()
            
        dfs(0)
        return ans
```
#### ② 输出角度 枚举选哪个
![](回溯-Pictures\1-5.png)
为了避免重复，即[1,2] 和 [2,1]这种  
- 在子集中我们没有规定顺序，**那我们就自己规定一个顺序**，保证每次枚举的数字是 **大于i（即j）** 的，这样保证不会重复。
- 注意：此时的i表示枚举的起点

这样这棵树是这样嘟
![](回溯-Pictures\1-6.png)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        path = []
        ans = []
        n = len(nums)

        def dfs(i):
            # 对于答案来说每次都是答案
            ans.append(path.copy())
            if i == n: # 递归边界
                return
            
            # 枚举选哪个
            for j in range(i, n):
                path.append(nums[j])
                dfs(j+1)
                path.pop() # 恢复现场
        
        dfs(0)
        return ans
```

举例应用：[131.分割回文串](https://leetcode.cn/problems/palindrome-partitioning/description/)