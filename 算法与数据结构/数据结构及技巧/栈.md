## stack 
## 栈 
#### 后进先出  
- 栈是一种后进先出（LIFO）的数据结构，非常适合处理需要**回退**的场景。
- 也适合维护距离当前**最近**的元素 -> 需要快速匹配**最近元素**的题目（如**括号匹配、镜像匹配**）  

#### ① 基础 
[1441 用栈操作构造数组](https://leetcode.cn/problems/build-an-array-with-stack-operations/)
```python
class Solution:
    def buildArray(self, target: List[int], n: int) -> List[str]:
        ans = []
        x = "Push"
        y = "Pop"
        cur = 1
        for num in target:
            while cur < num:
                ans.append(x)
                ans.append(y)
                cur += 1
            ans.append(x)
            cur += 1
        return ans
```
注重关注最后一个元素！**栈顶元素**

[946.验证栈序列](https://leetcode.cn/problems/validate-stack-sequences/description/)
```python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        st = []
        i = 0
        for x in pushed:
            st.append(x)
            while i < len(popped) - 1 and st and st[-1] == popped[i]:
                st.pop()
                i += 1
        return i == len(popped) - 1
```

---

#### ② 进阶模块
##### Ⅰ26个栈维护方法
[3412.计算字符串的镜像分数](https://leetcode.cn/problems/find-mirror-score-of-a-string/description/)
```python
class Solution:
    def calculateScore(self, s: str) -> int:
        stk = [[] for _ in range(26)]
        ans = 0
        for i, c in enumerate(map(ord, s)):
            c -= ord('a')
            if stk[25 - c]:
                ans += i - stk[25 - c].pop()
            else:
                stk[c].append(i)
        return ans
```
- 其实感觉类似哈希表，只是需要多维护一个最近的元素下标，所以维护对称的数组存对应的下标，然后找**最近的**也就是弹出栈顶元素罢了
- 这种26个栈的方式 -> **需要快速匹配最近元素的题目（如括号匹配、镜像匹配）**

[3170.删除星号以后字典序最小的字符串](https://leetcode.cn/problems/lexicographically-minimum-string-after-removing-stars/description/)
```python
class Solution:
    def clearStars(self, s: str) -> str:
        st = [[] for _ in range(26)]
        for i, c in enumerate(s):
            if c != '*':
                st[ord(c) - ord('a')].append(i)
                continue
            for p in st:
                if p:
                    p.pop()
                    break
        return ''.join(s[i] for i in sorted(chain.from_iterable(st)))
```
综合考虑题目之后也是要来删除**后面的**最小序好（删前面的，后面大的补上来，这样的话字典序会变小），等于说还是在找**最近的**最小元素

---

#### ③ 邻项消除
[2696.删除子串后字符串的最小长度](https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/description/)
```python
class Solution:
    def minLength(self, s: str) -> int:
        st = []
        for c in s:
            if st and (c == 'B' and st[-1] == 'A' or c == 'D' and st[-1] == 'C'):
                st.pop()
            else:
                st.append(c)
        return len(st)
```
你会发现我们还是盯着栈顶和遍历到的元素

---

#### ④ 合法括号字符串
[20.有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)
```python
class Solution:
    def isValid(self, s: str) -> bool:
        # if len(s) % 2:  # s 长度必须是偶数
        #     return False
        # mp = {')': '(', ']': '[', '}': '{'}
        # st = []
        # for c in s:
        #     if c not in mp:  # c 是左括号
        #         st.append(c)  # 入栈
        #     elif not st or st.pop() != mp[c]:  # c 是右括号
        #         return False  # 没有左括号，或者左括号类型不对
        # return not st  # 所有左括号必须匹配完毕
        if len(s) % 2:  # s 长度必须是偶数
            return False
        st = []
        for c in s:
            if c == '(':
                st.append(')')  # 入栈对应的右括号
            elif c == '[':
                st.append(']')
            elif c == '{':
                st.append('}')
            elif not st or st.pop() != c:  # c 是右括号
                return False  # 没有左括号，或者左括号类型不对
        return not st  # 所有左括号必须匹配完毕
```