## 基础算法——九大排序  
| 排序算法     | 最好时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 | 适用场景                     |
|--------------|----------------|----------------|----------------|------------|--------|------------------------------|
| 冒泡排序     | O(n)           | O(n²)          | O(n²)          | O(1)       | 稳定   | 小规模数据/教学示例          |
| 选择排序     | O(n²)          | O(n²)          | O(n²)          | O(1)       | 不稳定 | 小规模数据                   |
| 插入排序     | O(n)           | O(n²)          | O(n²)          | O(1)       | 稳定   | 小规模/基本有序数据          |
| 希尔排序     | O(n log n)     | O(n log² n)    | O(n²)          | O(1)       | 不稳定 | 中等规模数据                 |
| 归并排序     | O(n log n)     | O(n log n)     | O(n log n)     | O(n)       | 稳定   | 大规模数据/需要稳定性        |
| 快速排序     | O(n log n)     | O(n log n)     | O(n²)          | O(log n)   | 不稳定 | 大规模数据/通用排序          |
| 堆排序       | O(n log n)     | O(n log n)     | O(n log n)     | O(1)       | 不稳定 | 大规模数据/内存受限场景      |
| 计数排序     | O(n + k)       | O(n + k)       | O(n + k)       | O(k)       | 稳定   | 非负整数/数据范围小          |
| 基数排序     | O(nk)          | O(nk)          | O(nk)          | O(n + k)   | 稳定   | 多关键字排序/固定位数数据    |
```python
"""
前置的查找方式：顺序查找与二分查找
排序：
Low B三人组：冒泡排序，选择排序，插入排序 O(n²)
NB三人组：快速排序，堆排序，归并排序 O(nlogn)
其他：希尔排序 O(nlog²n)，计数排序 O(n+k)（k是数据范围），基数排序 O(nk)（k是数字位数）
"""


def linear_search(data_set, value):  # 顺序查找 O(n)
    for i in range(len(data_set)):
        if data_set[i] == value:
            return i
    return


def bubble_sort(li):  # 冒泡排序
    for i in range(len(li) - 1):  # 第i趟
        exchange = False
        for j in range(len(li) - i - 1):  # 到每一趟的倒数第二个元素即可，因为有个j+1;-i:去除有序区元素
            if li[j] > li[j + 1]:
                li[j], li[j + 1] = li[j + 1], li[j]
                exchange = True  # 换了位置就true
        print(li)
        if not exchange:  # 每一趟检验一次
            return


def select_sort(li):  # 选择排序
    for i in range(len(li) - 1):  # i是第几趟(趟得-1，因为从第0趟开始，也就是下标，也不用搞到最后一个元素)
        min_loc = i
        for j in range(i + 1, len(li)):
            if li[j] < li[min_loc]:
                min_loc = j
        if min_loc != i:
            li[i], li[min_loc] = li[min_loc], li[i]


def insert_sort(li):  # 插入排序
    for i in range(1, len(li)):  # i表示摸到的牌的下标
        tmp = li[i]
        j = i - 1  # j指的是手里牌的下标（有序区最后一个）
        while j >= 0 and li[j] > tmp:
            li[j + 1] = li[j]
            j -= 1  # 上面的值先往后移，然后j往左移，最后在while循环结束后的j+1（j在结束前也还是向左移了）的位置插入摸到的新牌
        li[j + 1] = tmp
        print(li)


def partition(li, left, right):  # 快速排序
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp:  # 从右边找比tmp小的数
            right -= 1  # 往左走一步
        li[left] = li[right]  # 把右边的值写到左边空位上
        while left < right and li[left] <= tmp:
            left += 1  # 往右走一步
        li[right] = li[left]  # 把左边的值写到右边空位上
    li[left] = tmp  # 把tmp归位（此时left与right重合，其实也就是mid的指针）
    return left


def quick_sort(li, left, right): # 快速排序
    if left < right:  # 至少两个元素
        mid = partition(li, left, right)
        quick_sort(li, left, mid - 1)
        quick_sort(li, mid + 1, right)


def sift(li, low, high): # 堆排序 -> 从上往下调整 向下调整函数
    """
    :param li: 列表
    :param low: 堆的根节点位置
    :param high: 堆的最后一个元素的位置
    :return:
    """
    i = low  # i最开始指向根节点
    j = 2 * i + 1  # j开始是左孩子
    tmp = li[low]  # 把堆顶存起来
    while i <= high:  # 只要j位置有数
        if j + 1 <= high and li[j + 1] > li[j]:  # 如果右孩子有并且比较大
            j += 1  # j指向右孩子
        if li[j] > tmp:
            li[i] = li[j]
            i = j  # 往下看一层
            j = 2 * i + 1
        else:  # tmp更大，把tmp放到i的位置上
            li[i] = tmp  # 把tmp放到某一级领导位置上
            break
    else:
        li[i] = tmp  # 把tmp放到叶子节点上


def heap_sort(li): # 堆排序
    n = len(li)
    for i in range((n - 2) // 2, -1, -1):
        # i 表示建堆的时候调整的部分的根的下标
        sift(li, i, n - 1)
    # 建堆完成了
    for i in range(n - 1, -1, -1):  # 表示从n-1到0，倒序
        # i z指向当前堆的最后一个元素
        li[0], li[i] = li[i], li[0]
        sift(li, 0, i - 1)  # i-1是新的high


def merge(li, low, mid, high):  # 归并排序的合并：把两个有序的合并并排好序
    i = low
    j = mid + 1
    tmp = []
    while i <= mid and j <= high:  # 只要左右两边都有数
        if li[i] < li[j]:
            tmp.append(li[i])
            i += 1
        else:
            tmp.append(li[j])
            j += 1
    # while执行完，肯定有一部分没数了
    while i <= mid:
        tmp.append(li[i])
        i += 1
    while j <= high:
        tmp.append(li[j])
        j += 1
    li[low:high + 1] = tmp


def merge_sort(li, low, high):  # 无限分成更小的，直到剩一个成为有序，再递归调用排序函数，最后合并
    if low < high:  # 至少有两个元素，递归
        mid = (low + high) // 2
        merge_sort(li, low, mid)
        merge_sort(li, mid + 1, high)
        merge(li, low, mid, high)


def insert_sort_gap(li, gap): # 希尔排序
    for i in range(gap, len(li)):  # i 表示摸到的牌的下标
        tmp = li[i]
        j = i - gap  # j指的是手里的牌的下标
        while j >= 0 and li[j] > tmp:
            li[j + gap] = li[j]
            j -= gap
        li[j + gap] = tmp


def shell_sort(li):  # 希尔排序
    d = len(li) // 2
    while d >= 1:
        insert_sort_gap(li, d)
        d //= 2


def count_sort(li, max_count=100):  # 计数排序
    count = [0 for i in range(max_count + 1)]
    for val in li:
        count[val] += 1
    li.clear()
    for ind, val in enumerate(count):
        for i in range(val):
            li.append(ind)


# def bucket_sort(li, n=100, max_num=10000):  # 桶排序
#     buckets = [[] for _ in range(n)]  # 创建桶
#     for var in li:
#         i = min(var // (max_num // n), n - 1)  # i表示var放到几号桶里
#         buckets[i].append(var)  # 把var加到桶里面
#         # 保持桶内的顺序
#         for j in range(len(buckets[i]), 0, -1):
#             if buckets[i][j] < buckets[i][j - 1]:
#                 buckets[i][j], buckets[i][j - 1] = buckets[i][j - 1], buckets[i][j]
#             else:
#                 break
#     sorted_li = []
#     for buc in buckets:
#         sorted_li.extend(buc)
#     return sorted_li


def radix_sort(li):  # 基数排序
    max_num = max(li)  # 最大值 9->1, 99->2, 888->3, 10000->5
    it = 0
    while 10 ** it <= max_num:
        buckets = [[] for _ in range(10)]
        for var in li:
            # 987 it=1 987 // 10->98 98%10->8;  it=2, 987 // 100->9 9%10->9
            digit = (var // 10 ** it) % 10
            buckets[digit].append(var)
        # 分桶完成
        li.clear()
        for buc in buckets:
            li.extend(buc)
        # 把数重新写回li
        it += 1













