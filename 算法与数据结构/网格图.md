## ç½‘æ ¼å›¾ DFS BFS ç»¼åˆè¿ç”¨
[é¢˜å•](https://leetcode.cn/discuss/post/3580195/fen-xiang-gun-ti-dan-wang-ge-tu-dfsbfszo-l3pa/)  
### â‘  ç½‘æ ¼å›¾ DFS
é€‚ç”¨äºéœ€è¦è®¡ç®—**è¿é€šå—ä¸ªæ•°ã€å¤§å°**çš„é¢˜ç›®ã€‚  
éƒ¨åˆ†é¢˜ç›®ä¹Ÿå¯ä»¥ç”¨ BFS æˆ–å¹¶æŸ¥é›†è§£å†³ã€‚  
- **è®°å¾—æ’æ——**ï¼ï¼ï¼é¿å…æ¥å›çš„æ— é™é€’å½’  

å…¥é—¨é¢˜ï¼š[200.å²›å±¿æ•°é‡](https://leetcode.cn/problems/number-of-islands/description/)  
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0]) # m, n ä»£è¡¨äº†é•¿å’Œå®½
        def dfs(i, j):
            # å‡ºç•Œï¼Œæˆ–è€…ä¸æ˜¯"1"ï¼Œå°±ä¸å†å‘ä¸‹é€’å½’
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':
                return
            grid[i][j] = '2' # æ’æ——ï¼ï¼ï¼é¿å…æ¥å›çš„æ— é™é€’å½’
            # å·¦å³ä¸Šä¸‹
            dfs(i, j - 1)
            dfs(i, j + 1)
            dfs(i - 1, j)
            dfs(i + 1, j)
        
        ans = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                if c == '1': # æ‰¾åˆ°äº†ä¸€ä¸ªæ–°çš„å²›
                    dfs(i, j) # iï¼Œ jæ˜¯è¡Œå’Œåˆ— æŠŠè¿™ä¸ªå²›æ’æ»¡ğŸš©ï¼Œè¿™æ ·åé¢çš„"1"éƒ½æ˜¯æ–°çš„å²›
                    ans += 1
        return ans
```

- **éå†å¤šæ–¹å‘/å…¨dfsä¸Šä¸‹å·¦å³**å†™æ³•äºŒé€‰ä¸€ï¼Œä½†ä¸€èˆ¬æ–¹å‘å¤šçš„è¯å°±éå†å¤šæ–¹å‘å§  

[695.å²›å±¿çš„æœ€å¤§é¢ç§¯](https://leetcode.cn/problems/max-area-of-island/description/)
```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        def dfs(i, j):
            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != 1:
                return 0
            grid[i][j] = 2 # æ’æ——
            # area = 1 #å…¨dfs
            # area += dfs(i, j - 1)
            # area += dfs(i, j + 1)
            # area += dfs(i - 1, j)
            # area += dfs(i + 1, j)
            area = 1 # éå†å¤šæ–¹å‘
            for x, y in (i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j):
                if 0 <= x <= m - 1 and 0 <= y <= n - 1:
                    area += dfs(x, y)
            return area
        
        ans = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                if c == 1:
                    ans = max(ans, dfs(i, j))
        return ans
```
- ç”±è¿™é“é¢˜æ¥ç»™å‡º**ä¸¤ç§åˆ¤æ–­è¾¹ç•Œæ¡ä»¶**çš„ä¸åŒå†™æ³•ï¼Œåˆ°æ—¶å€™çœ‹å“ªä¸ªé¡ºæ‰‹å°±ç”¨å“ªä¸ªå§

[é¢è¯•é¢˜16.19.æ°´åŸŸå¤§å°](https://leetcode.cn/problems/pond-sizes-lcci/)
```python
class Solution:
    def pondSizes(self, land: List[List[int]]) -> List[int]:
        m = len(land)
        n = len(land[0])
        def dfs(x: int, y: int) -> int:
            if x < 0 or x >= m or y < 0 or y >= n or land[x][y] != 0:
                return 0
            land[x][y] = 1  # æ ‡è®° (x,y) è¢«è®¿é—®ï¼Œé¿å…é‡å¤è®¿é—®
            cnt0 = 1
            # è®¿é—®å…«æ–¹å‘çš„ 0
            for i in range(x - 1, x + 2):
                for j in range(y - 1, y + 2):
                    # if 0 <= i < m and 0 <= j < n and land[i][j] == 0: # åˆç†çš„æ‰åŠ  è¿™ä¸€å¥ä¸ä¸Šé¢è¾¹ç•Œæ¡ä»¶åˆ¤æ–­äºŒé€‰ä¸€å†™å°±è¡Œ
                    cnt0 += dfs(i, j)
            return cnt0

        ans = []
        for i, row in enumerate(land):
            for j, c in enumerate(row):
                if c == 0:
                    res = dfs(i, j)
                    ans.append(res)
        ans.sort()
        return ans
```
| å†™æ³• | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|------|------|
| **ç¬¬äºŒç§ï¼ˆå¾ªç¯å†…éƒ¨åˆ¤æ–­ï¼‰** | è¿è¡Œé€Ÿåº¦æ›´å¿«ï¼Œå‡å°‘æ— ç”¨é€’å½’è°ƒç”¨ | ä»£ç ç•¥å¤æ‚ï¼Œéœ€è¦æ‰‹åŠ¨å¤„ç†è¾¹ç•Œæ¡ä»¶ |
| **ç¬¬ä¸€ç§ï¼ˆé€’å½’å‡½æ•°å…¥å£åˆ¤æ–­ï¼‰** | ä»£ç ç®€æ´ï¼Œé€»è¾‘æ¸…æ™° | ä¼šè§¦å‘å¤§é‡æ— ç”¨é€’å½’è°ƒç”¨ï¼Œæ€§èƒ½è¾ƒå·® |

æœ‰äº›é¢˜ç›®é€’å½’è¾¹ç•Œæ¡ä»¶èƒ½å†™ï¼Œä½†æ˜¯å¾ªç¯çš„æ—¶å€™æˆ‘è½¬åŒ–ä¸è¿‡å»ï¼Œå†ç­‰æˆ‘æ‚Ÿä¸€æ‚Ÿ  
- æ³¨æ„ï¼šè¦å­¦ä¼šæŠŠè¾¹ç•Œæ¡ä»¶å½’ç±»ï¼Œå³ä»€ä¹ˆç±»å‹è¿”å›å€¼æ˜¯ä¸€ç§ï¼Œå¦ä¸€ä¸ªç±»å‹åˆæ˜¯å¦ä¸€ç§æƒ…å†µï¼Œå¦‚ä¸‹é¢˜  
- æ­¤å¤–ï¼Œå¦‚æœå‘ç°éœ€è¦åœ¨**å¾ªç¯**é‡Œåˆ¤æ–­è¾¹ç•Œæ¡ä»¶ï¼Œå°±åœ¨å¾ªç¯é‡Œåˆ¤æ–­åˆæ³•æ¡ä»¶ï¼Œä¸‹é¢ä¸¤é¢˜æ˜¯å¾ˆå¥½çš„è¯æ˜ï¼  


[LCS 03.ä¸»é¢˜ç©ºé—´](https://leetcode.cn/problems/YesdPw/description/) ç†è§£æœ‰ç‚¹å¥‡æ€ªå‘¢ æ„Ÿè§‰ä¸éš¾ä½†è€æ˜¯æœ‰ç‚¹æƒ³ä¸åˆ°å•Š  
```python
class Solution:
    def largestArea(self, grid: List[str]) -> int:
        grid = [list(i) for i in grid]
        m, n = len(grid), len(grid[0])
        def dfs(i, j):
            nonlocal begin_val
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0': # å…¶å®å‡ºç•Œå’Œ==0åœ¨é¢˜ç›®ä¸­ç†è§£éƒ½æ˜¯ä¸€æ ·çš„ è·Ÿä»¥å‰æ²¡ä»€ä¹ˆå˜åŒ–
                return -inf
            if grid[i][j] != begin_val: # ä¸æ˜¯åŒä¸€ä¸ªå²› != å‡ºç•Œ or 0ï¼ï¼ï¼
                return 0
            grid[i][j] = 'k' # æ’æ——
            res = 1
            # res += dfs(i,j + 1)
            # res += dfs(i,j - 1)
            # res += dfs(i + 1,j)
            # res += dfs(i - 1,j)
            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):
                res += dfs(x, y)
            return res

        ans = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                begin_val = grid[i][j] #  è®°å½•å¼€å§‹å€¼ ä¸ºäº†åˆ¤æ–­æ˜¯ä¸æ˜¯åŒä¸€å—åŒºåŸŸ
                if c != '0' and c != 'k':
                    ans = max(ans, dfs(i, j))
        return ans
```

[1034.è¾¹ç•Œç€è‰²](https://leetcode.cn/problems/coloring-a-border/description/)  
**å¯¹è¾¹ç•Œå’Œæ¡ä»¶å¤„ç†ä¸ä½³**  
æ ¹æ®æˆ‘ä¸Šé¢è¯´çš„ï¼Œå‘ç°éœ€è¦åœ¨å¾ªç¯é‡Œåˆ¤æ–­æ¡ä»¶æ¥ç¡®å®šæ˜¯å¦é€’å½’ï¼š
- é€’å½’æ¡ä»¶ï¼šåœ¨gridå†…å¹¶ä¸”ä¸‹ä¸€ä¸ªæ–¹å‘çš„å€¼å’Œé€’å½’å…¥å£çš„å€¼ä¸€æ ·ï¼šç»§ç»­DFSå¯»æ‰¾è¿é€šå—ï¼ˆè¿™é‡Œå’Œå‰é¢å¹¶æ— åŒºåˆ«ï¼Œè®°å¾—æ’æ——ç­‰ç­‰ï¼‰
- æŸ“è‰²æ¡ä»¶ï¼šä½ ä¼šå‘ç°åªè¦æœ‰ä¸€ä¸ªæ–¹å‘çš„å€¼ä¸ç­‰äºé€’å½’å…¥å£çš„å€¼å°±å¯ä»¥æŸ“è‰²äº†ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œæœ‰ä¸ªif elseçš„æ¡ä»¶åˆ¤æ–­ï¼›ä½†æ˜¯ä½ å‘ç°å¦‚æœå››æ–¹å‘ä¸­æœ‰ä¸€ä¸ªå‡ºgridçš„äº†å°±è¯´æ˜æ˜¯åœ¨è¾¹ç•Œä¸Šï¼Œæ­¤æ—¶ä¹Ÿè¦æŸ“è‰²ï¼

å¦‚ä½•å®šä¹‰è¿é€šåˆ†é‡è¾¹ç•Œï¼Ÿ
1. é¢œè‰²ä¸grid[row][col]ç›¸åŒï¼Œä¸è¿é€šåˆ†é‡è¿æ¥ï¼Œè¿™ä¸¤ä¸ªæ˜¯å¿…é¡»æ»¡è¶³çš„æ¡ä»¶
2. å½“æ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„ç‚¹å‡ºç°åœ¨æœ€å¤–ä¸€åœˆæ—¶ï¼Œå¿…ä¸ºè¾¹ç•Œã€‚

3. å½“æ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„ç‚¹å‡ºç°åœ¨å†…åœˆæ—¶ï¼Œå¦‚æœå®ƒå››å‘¨æœ‰ä¸€ä¸ªç‚¹ä¸grid[row][col]é¢œè‰²ä¸åŒï¼Œä¸ºè¾¹ç•Œã€‚
   
å¦å¤–ï¼Œå¦‚æœæ˜¯éœ€è¦åœ¨åŸgridåšä¿®æ”¹ï¼Œå°±é¢å¤–å¼€ä¸€ä¸ªvisited/é›†åˆæ¥è®°å½•èµ°è¿‡çš„ç‚¹å§
```python
class Solution:
    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        cnt = set()
        target = grid[row][col]
        cnt.add((row, col)) # whyä¸ç”¨æ›´æ”¹åŸçŸ©é˜µå‘¢ï¼Ÿæ”¹äº†ä¸å¥½åˆ¤æ–­çœŸæ­£æŸ“è‰²åçš„æ•°ç»„äº†ï¼Œæ‰€ä»¥å¦å¼€ä¸€ä¸ªç©ºé—´ï¼ˆç›¸å½“äºvisitedæ•°ç»„ï¼‰è¿›æ¥æ¥å­˜å‚¨èµ°è¿‡çš„ç‚¹

        def dfs(i, j):
            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):
                if 0 <= x < m and 0 <= y < n: # é¦–å…ˆè¿™ä¸ªå››å‘¨çš„ç‚¹åœ¨ä¸´ç•Œå†…
                    if (x, y) not in cnt: # æœªè®¿é—®è¿‡
                        if grid[x][y] == target: # å¦‚æœå››æ–¹å‘æœ‰ä¸ªç­‰äºtargetäº†ï¼Œå°±å¯ä»¥ç»§ç»­é€’å½’ä»–å»æ‰¾è¾¹ç•Œ
                            cnt.add((x, y))
                            dfs(x, y)
                        else: #å¦‚æœå››å‘¨æœ‰ä¸€ä¸ªç‚¹ä¸åŸtargetä¸åŒï¼Œå°±ä¸ºè¾¹ç•Œ
                            grid[i][j] = color
                else: # æ‰©æ•£å››æ–¹å‘æœ‰å‡ºç°å‡ºç•Œäº†ï¼Œiï¼Œjå¿…ä¸ºè¾¹ç•Œ
                    grid[i][j] = color

        dfs(row, col)
        return grid
```


### â‘¡ ç½‘æ ¼å›¾ BFS
[1926.è¿·å®«ä¸­ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/description/)
```python
class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        m, n = len(maze), len(maze[0])
        # q = [(entrance[0], entrance[1])]
        q = deque()
        q.append(entrance)
        ans = 0
        while q:
            for _ in range(len(q)):
                i, j = q.popleft()
                maze[i][j] = "+"
            # tmp = q
            # q = []
            # for i, j in tmp:
                if (i == 0 or i == m - 1 or j == 0 or j == n - 1) and not (i == entrance[0] and j == entrance[1]): # å°±å·®è¿™é‡Œ
                    return ans
                for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):
                    if 0 <= x < m and 0 <= y < n and maze[x][y] == '.':
                        maze[x][y] = '+'
                        q.append((x, y))
            ans += 1

        return -1
```
é¢å¤–çš„çŸ¥è¯†ï¼š
- 