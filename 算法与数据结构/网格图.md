## 网格图 DFS BFS 综合运用
[题单](https://leetcode.cn/discuss/post/3580195/fen-xiang-gun-ti-dan-wang-ge-tu-dfsbfszo-l3pa/)  
### ① 网格图 DFS
适用于需要计算**连通块个数、大小**的题目。  
部分题目也可以用 BFS 或并查集解决。  
- **记得插旗**！！！避免来回的无限递归  

入门题：[200.岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)  
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0]) # m, n 代表了长和宽
        def dfs(i, j):
            # 出界，或者不是"1"，就不再向下递归
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':
                return
            grid[i][j] = '2' # 插旗！！！避免来回的无限递归
            # 左右上下
            dfs(i, j - 1)
            dfs(i, j + 1)
            dfs(i - 1, j)
            dfs(i + 1, j)
        
        ans = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                if c == '1': # 找到了一个新的岛
                    dfs(i, j) # i， j是行和列 把这个岛插满🚩，这样后面的"1"都是新的岛
                    ans += 1
        return ans
```

- **遍历多方向/全dfs上下左右**写法二选一，但一般方向多的话就遍历多方向吧  

[695.岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/description/)
```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        def dfs(i, j):
            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != 1:
                return 0
            grid[i][j] = 2 # 插旗
            # area = 1 #全dfs
            # area += dfs(i, j - 1)
            # area += dfs(i, j + 1)
            # area += dfs(i - 1, j)
            # area += dfs(i + 1, j)
            area = 1 # 遍历多方向
            for x, y in (i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j):
                if 0 <= x <= m - 1 and 0 <= y <= n - 1:
                    area += dfs(x, y)
            return area
        
        ans = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                if c == 1:
                    ans = max(ans, dfs(i, j))
        return ans
```
- 由这道题来给出**两种判断边界条件**的不同写法，到时候看哪个顺手就用哪个吧

[面试题16.19.水域大小](https://leetcode.cn/problems/pond-sizes-lcci/)
```python
class Solution:
    def pondSizes(self, land: List[List[int]]) -> List[int]:
        m = len(land)
        n = len(land[0])
        def dfs(x: int, y: int) -> int:
            if x < 0 or x >= m or y < 0 or y >= n or land[x][y] != 0:
                return 0
            land[x][y] = 1  # 标记 (x,y) 被访问，避免重复访问
            cnt0 = 1
            # 访问八方向的 0
            for i in range(x - 1, x + 2):
                for j in range(y - 1, y + 2):
                    # if 0 <= i < m and 0 <= j < n and land[i][j] == 0: # 合理的才加 这一句与上面边界条件判断二选一写就行
                    cnt0 += dfs(i, j)
            return cnt0

        ans = []
        for i, row in enumerate(land):
            for j, c in enumerate(row):
                if c == 0:
                    res = dfs(i, j)
                    ans.append(res)
        ans.sort()
        return ans
```
| 写法 | 优点 | 缺点 |
|------|------|------|
| **第二种（循环内部判断）** | 运行速度更快，减少无用递归调用 | 代码略复杂，需要手动处理边界条件 |
| **第一种（递归函数入口判断）** | 代码简洁，逻辑清晰 | 会触发大量无用递归调用，性能较差 |

有些题目递归边界条件能写，但是循环的时候我转化不过去，再等我悟一悟  
- 注意：要学会把边界条件归类，即什么类型返回值是一种，另一个类型又是另一种情况，如下题  
- 此外，如果发现需要在**循环**里判断边界条件，就在循环里判断合法条件，下面两题是很好的证明！  


[LCS 03.主题空间](https://leetcode.cn/problems/YesdPw/description/) 理解有点奇怪呢 感觉不难但老是有点想不到啊  
```python
class Solution:
    def largestArea(self, grid: List[str]) -> int:
        grid = [list(i) for i in grid]
        m, n = len(grid), len(grid[0])
        def dfs(i, j):
            nonlocal begin_val
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0': # 其实出界和==0在题目中理解都是一样的 跟以前没什么变化
                return -inf
            if grid[i][j] != begin_val: # 不是同一个岛 != 出界 or 0！！！
                return 0
            grid[i][j] = 'k' # 插旗
            res = 1
            # res += dfs(i,j + 1)
            # res += dfs(i,j - 1)
            # res += dfs(i + 1,j)
            # res += dfs(i - 1,j)
            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):
                res += dfs(x, y)
            return res

        ans = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                begin_val = grid[i][j] #  记录开始值 为了判断是不是同一块区域
                if c != '0' and c != 'k':
                    ans = max(ans, dfs(i, j))
        return ans
```

[1034.边界着色](https://leetcode.cn/problems/coloring-a-border/description/)  
**对边界和条件处理不佳**  
根据我上面说的，发现需要在循环里判断条件来确定是否递归：
- 递归条件：在grid内并且下一个方向的值和递归入口的值一样：继续DFS寻找连通块（这里和前面并无区别，记得插旗等等）
- 染色条件：你会发现只要有一个方向的值不等于递归入口的值就可以染色了，所以在这里有个if else的条件判断；但是你发现如果四方向中有一个出grid的了就说明是在边界上，此时也要染色！

如何定义连通分量边界？
1. 颜色与grid[row][col]相同，与连通分量连接，这两个是必须满足的条件
2. 当满足上述条件的点出现在最外一圈时，必为边界。

3. 当满足上述条件的点出现在内圈时，如果它四周有一个点与grid[row][col]颜色不同，为边界。
   
另外，如果是需要在原grid做修改，就额外开一个visited/集合来记录走过的点吧
```python
class Solution:
    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        cnt = set()
        target = grid[row][col]
        cnt.add((row, col)) # why不用更改原矩阵呢？改了不好判断真正染色后的数组了，所以另开一个空间（相当于visited数组）进来来存储走过的点

        def dfs(i, j):
            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):
                if 0 <= x < m and 0 <= y < n: # 首先这个四周的点在临界内
                    if (x, y) not in cnt: # 未访问过
                        if grid[x][y] == target: # 如果四方向有个等于target了，就可以继续递归他去找边界
                            cnt.add((x, y))
                            dfs(x, y)
                        else: #如果四周有一个点与原target不同，就为边界
                            grid[i][j] = color
                else: # 扩散四方向有出现出界了，i，j必为边界
                    grid[i][j] = color

        dfs(row, col)
        return grid
```


### ② 网格图 BFS
[1926.迷宫中离入口最近的出口](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/description/)
```python
class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        m, n = len(maze), len(maze[0])
        # q = [(entrance[0], entrance[1])]
        q = deque()
        q.append(entrance)
        ans = 0
        while q:
            for _ in range(len(q)):
                i, j = q.popleft()
                maze[i][j] = "+"
            # tmp = q
            # q = []
            # for i, j in tmp:
                if (i == 0 or i == m - 1 or j == 0 or j == n - 1) and not (i == entrance[0] and j == entrance[1]): # 就差这里
                    return ans
                for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):
                    if 0 <= x < m and 0 <= y < n and maze[x][y] == '.':
                        maze[x][y] = '+'
                        q.append((x, y))
            ans += 1

        return -1
```
额外的知识：
- 