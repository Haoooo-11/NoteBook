## 贪心算法
[【算法题单】贪心算法（基本贪心策略/反悔/区间/字典序/数学/思维/构造）](https://leetcode.cn/discuss/post/3091107/fen-xiang-gun-ti-dan-tan-xin-ji-ben-tan-k58yb/)  
有时候很难分清用贪心还是DP  
局部最优解 由局部最优推到全局最优解
### ① 贪心策略
有两种基本贪心策略：
- 从**最小/最大**开始贪心，优先考虑**最小/最大**的数，**从小到大/从大到小**贪心。在此基础上，衍生出了**反悔**贪心。
- 从**最左/最右**开始贪心，思考**第一个数/最后一个数**的贪心策略，把 n 个数的原问题转换成 **n−1 个数（或更少）的子问题。**

#### §1.1 从最小/最大开始贪心
- 优先考虑最小/最大的数，从小到大/从大到小贪心。  
- 如果答案与数组元素顺序无关，一般需要**排序**。排序后，可以遍历计算。
[3397.执行操作后不同元素的最大数量](https://leetcode.cn/problems/maximum-number-of-distinct-elements-after-operations/description/)
```python
class Solution:
    def maxDistinctElements(self, nums: List[int], k: int) -> int:
        # nums.sort()
        # dic = defaultdict(int)
        # if (2 * k + 1) >= len(nums):
        #     return len(nums)
        # for num in nums:
        #     even = True
        #     for x in range(num - k, num + k + 1):
        #         if x not in dic:
        #             even = False
        #             dic[x] = 1
        #             break
        #     if even:
        #         dic[num] += 1
        # return len(dic.keys())
        if k * 2 + 1 >= len(nums):
            return len(nums)

        nums.sort()
        ans = 0
        pre = -inf  # 记录每个人左边的人的位置
        for x in nums:
            x = min(max(x - k, pre + 1), x + k) # 这个好啊
            if x > pre:
                ans += 1
                pre = x # 维护前面的值
        return ans


